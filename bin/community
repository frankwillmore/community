#!/usr/bin/env bash 

# (C) 2021 Argonne Leadership Computing Facility, with primary concept by Frank Willmore
# This is free software with no implied warranty.

# Print the message $1 and exit with the provided return code $2
cmd_quit()
{
    echo "FAIL: $1"
    echo "FAIL: exiting with code $2"
    exit "$2"
}

# Make sure that COMMUNITY_ROOT is set and exit if it is not.
[ -z "${COMMUNITY_ROOT}" ] && cmd_quit "COMMUNITY_ROOT must be set (e.g. to /soft/community) to run community commands" 126

# Source .communityrc to pick up local values
[ -e "${COMMUNITY_ROOT}/etc/.communityrc" ] && . "${COMMUNITY_ROOT}/etc/.communityrc"

# set defaults if not found in .communityrc
: "${COMMUNITY_FILESYSTEM:='/lus/theta-fs0'}"
: "${GENERATE_COMMANDS_ONLY:=true}"
: "${COMMUNITY_SCRIPT_DEBUG:='n'}"
: "${COMMUNITY_ROOT:='/soft/community'}"
: "${EXISTING_PROJECT_PATH:='/projects'}"
: "${COMMUNITY_PROJECT_DIR=${COMMUNITY_ROOT}/projects}"
: "${COMMUNITY_PROJECT_MODULE_DIR=${COMMUNITY_ROOT}/modulefiles}"

#COMMUNITY_PROJECT_DIR=${COMMUNITY_ROOT}/projects
#COMMUNITY_PROJECT_MODULE_DIR=${COMMUNITY_ROOT}/modulefiles

debug()
{
    [ "${COMMUNITY_SCRIPT_DEBUG}" = "y" ] && echo "DEBUG: $*"
}

# Poll for input, then make sure it matches only characters in regular expression.
# If it does not, reject it and poll again. 

request_and_validate_input()
{
    COMMUNITY_VALIDATED_INPUT=""
    while [ "${COMMUNITY_VALIDATED_INPUT}" = "" ]
    do  
        read -p "$1" COMMUNITY_UNVALIDATED_INPUT
        echo "${COMMUNITY_UNVALIDATED_INPUT}" | egrep "${COMMUNITY_VALIDATE_INPUT_REGEX}" 
        if [ "$?" = 0 ] 
        then
            COMMUNITY_VALIDATED_INPUT="${COMMUNITY_UNVALIDATED_INPUT}"
            return
        else
            printf "Input not valid, must use only characters in regular expression: \n" 
            printf "${COMMUNITY_VALIDATE_INPUT_REGEX}\n\n"
        fi  
    done
}

cmd_help() 
{
    printf "\n"
    printf "usage: community [ command ] [ community_name ]\n"
    printf "\n"
    printf "Where command is one of { create, delete, archive }\n" 
    printf "and community_name is the name of the community.\n"
    printf "\n" 
    printf "To specify a different community location, set COMMUNITY_ROOT\n"
    printf "(Default value is COMMUNITY_ROOT=/tmp/community)\n"
    printf "\n"
    printf "For deubgging info, set COMMUNITY_SCRIPT_DEBUG=y.\n"
    printf "\n"
    printf "By default, this program runs in 'safe mode', i.e."
    printf "commands will be generated and printed stdout but not executed.\n"
    printf "To automatically execute generated commands,\n"
    printf "set GENERATE_COMMANDS_ONLY to any value besides \"true\".\n"
    printf "\n"
    printf "\n"
}

cmd_create() 
{
    # PROJECT_DESCRIPTION, PROJECT_NAME, PROJECT_CONTACT, and PROJECT_ROOT are all 
    # tokens in the module template to be replaced. PROJECT_NAME is the 1st arg. 

    PROJECT_NAME=$1
    PROJECT_ROOT="${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}"
    MODULE_ROOT="${COMMUNITY_PROJECT_MODULE_DIR}/${PROJECT_NAME}"

    # check project eligibility
    eligible="false"
    for path in $(echo ${EXISTING_PROJECT_PATH} | sed -e "s/:/ /g")
    do
        debug "searching ${path}..."
        echo ${path}/${PROJECT_NAME} 
        if [ -e ${path}/${PROJECT_NAME} ] 
        then 
            eligible="true" 
            echo "found elgible path: ${path}/${PROJECT_NAME}"
        fi
    done
    [ ${eligible} = "true" ] || cmd_quit "Project ${PROJECT_NAME} not found." 126
    
    echo "creating community in ${PROJECT_ROOT} for project ${PROJECT_NAME}:"
    echo

    echo "Checking community doesn't already exist...."
    echo
    [ -e ${PROJECT_ROOT} ] && cmd_quit "Project ${PROJECT_NAME} already exists" 126

    # All is well, fill out module template fields.

    request_and_validate_input "Please enter brief project_description: "
    PROJECT_DESCRIPTION="${COMMUNITY_VALIDATED_INPUT}"
    debug "got PROJECT_DESCRIPTON=${PROJECT_DESCRIPTION}"
    echo

    request_and_validate_input "Please enter project contact: "
    PROJECT_CONTACT="${COMMUNITY_VALIDATED_INPUT}"
    debug "got PROJECT_CONTACT=${PROJECT_CONTACT}"
    echo

    request_and_validate_input "Please enter project user owner: "
    PROJECT_USER_OWNER="${COMMUNITY_VALIDATED_INPUT}"
    debug "got PROJECT_USER_OWNER=${PROJECT_USER_OWNER}"
    echo

    request_and_validate_input "Please enter project group owner: "
    PROJECT_GROUP_OWNER="${COMMUNITY_VALIDATED_INPUT}"
    debug "got PROJECT_GROUP_OWNER=${PROJECT_GROUP_OWNER}"
    echo

    # Done gathering info, now go do it.

    printf "creating software directory ${PROJECT_ROOT}..."
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo mkdir -p ${PROJECT_ROOT}" | tee -a ${CMD_SCRIPT} 
    else 
        mkdir -p ${PROJECT_ROOT}
    fi
    printf "done.\n"

    printf "creating module directory ${MODULE_ROOT}..."
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo mkdir -p ${MODULE_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        mkdir -p ${MODULE_ROOT}
    fi
    printf "done.\n"

    TEMPLATED_MODULE=${MODULE_ROOT}/${PROJECT_NAME}
    printf "adding template module file ${TEMPLATED_MODULE}..."
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo cp ${COMMUNITY_ROOT}/module_templates/module_template.tcl ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
    else 
        cp ${COMMUNITY_ROOT}/module_templates/module_template.tcl ${TEMPLATED_MODULE}
    fi
    printf "done.\n"

    printf "Replacing module template tokens with project info..."
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo sed -i -e \"s/\[\[PROJECT_NAME\]\]/${PROJECT_NAME}/g\" ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
        echo "sudo sed -i -e \"s#\[\[PROJECT_ROOT\]\]#${PROJECT_ROOT}#g\" ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
        echo "sudo sed -i -e \"s/\[\[PROJECT_CONTACT\]\]/${PROJECT_CONTACT}/g\" ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
        echo "sudo sed -i -e \"s/\[\[PROJECT_DESCRIPTION\]\]/${PROJECT_DESCRIPTION}/g\" ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
    else
        sed -i -e "s/\[\[PROJECT_NAME\]\]/${PROJECT_NAME}/g" ${TEMPLATED_MODULE}
        sed -i -e "s#\[\[PROJECT_ROOT\]\]#${PROJECT_ROOT}#g" ${TEMPLATED_MODULE}
        sed -i -e "s/\[\[PROJECT_CONTACT\]\]/${PROJECT_CONTACT}/g" ${TEMPLATED_MODULE}
        sed -i -e "s/\[\[PROJECT_DESCRIPTION\]\]/${PROJECT_DESCRIPTION}/g" ${TEMPLATED_MODULE}
    fi
    printf "done.\n"

    echo "making project dirs:"
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo mkdir -p ${PROJECT_ROOT}/bin" | tee -a ${CMD_SCRIPT} 
        echo "sudo mkdir -p ${PROJECT_ROOT}/share/man" | tee -a ${CMD_SCRIPT} 
        echo "sudo mkdir -p ${PROJECT_ROOT}/lib64" | tee -a ${CMD_SCRIPT} 
        echo "sudo mkdir -p ${PROJECT_ROOT}/lib64/pkgconfig" | tee -a ${CMD_SCRIPT} 
    else
        mkdir -p ${PROJECT_ROOT}/bin
        mkdir -p ${PROJECT_ROOT}/share/man
        mkdir -p ${PROJECT_ROOT}/lib64
        mkdir -p ${PROJECT_ROOT}/lib64/pkgconfig
    fi

    echo "setting ownership..."
    
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo chown -R ${PROJECT_USER_OWNER}:${PROJECT_GROUP_OWNER} ${PROJECT_ROOT}" | tee -a ${CMD_SCRIPT} 
        echo "sudo chown -R ${PROJECT_USER_OWNER}:${PROJECT_GROUP_OWNER} ${MODULE_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        sudo chown -R ${PROJECT_USER_OWNER}:${PROJECT_GROUP_OWNER} ${PROJECT_ROOT}
        sudo chown -R ${PROJECT_USER_OWNER}:${PROJECT_GROUP_OWNER} ${MODULE_ROOT}
    fi

    echo "setting quota..."
    
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo lfs setquota -g ${PROJECT_NAME} --block-softlimit 100G --block-hardlimit 105G ${COMMUNITY_FILESYSTEM}" | tee -a ${CMD_SCRIPT}
    else
        echo "sudo lfs setquota -g ${PROJECT_NAME} --block-softlimit 100G --block-hardlimit 105G ${COMMUNITY_FILESYSTEM}"
    fi

    printf "done.\n"

    cmd_exit 0
}

cmd_delete() 
{
    debug "deleting $1"

    PROJECT_NAME=$1
    PROJECT_ROOT="${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}"
    MODULE_ROOT="${COMMUNITY_PROJECT_MODULE_DIR}/${PROJECT_NAME}"
    
    echo "preparing to delete installs in ${PROJECT_ROOT}"
    echo "and modules in ${MODULE_ROOT} for project ${PROJECT_NAME}:"
    echo
    printf "Checking if community exists...."
    sleep 1
    if [ -e ${PROJECT_ROOT} ] 
    then 
        printf "yes.\n\n"
    else 
        printf "no.\n\n"
        cmd_quit "Project ${PROJECT_NAME} does not exist." 126
    fi

    read -p "Confirm delete (enter 'y' to confirm)? " confirm
    [ ${confirm} == "y" ] || cmd_quit "Change not confirmed. Exiting." 0

    echo "removing software directory ${PROJECT_ROOT}"
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo rm -rfv ${PROJECT_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        rm -rfv ${PROJECT_ROOT}
    fi
    echo

    echo "deleting module directory ${MODULE_ROOT}"
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo rm -rfv ${MODULE_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        rm -rfv ${MODULE_ROOT}
    fi
    echo

    echo "Done!"
    echo

    cmd_exit 0
}

cmd_archive() 
{
    echo "archiving $PROJECT_NAME"
    printf "Change user ownership of ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME} to community?\n"
    read -p "(enter y to confirm) " confirm
    if [ $confirm = "y" ] || [ $confirm = "yes" ] 
    then
        if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
        then
            echo "sudo chown -R ${ARCHIVE_USER_OWNER}:${ARCHIVE_GROUP_OWNER} ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}" | tee -a ${CMD_SCRIPT} 
            echo "sudo chmod -w -R ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}" | tee -a ${CMD_SCRIPT} 
        else
            sudo chown -R ${ARCHIVE_USER_OWNER}:${ARCHIVE_GROUP_OWNER} ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}
            sudo chmod -w -R ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}
        fi
    else
        echo "declining to update."
    fi

    cmd_exit 0
}

cmd_exit()
{ 
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]  
    then 
        echo 
        echo
        echo "Commands generated."
        echo
        echo "Please examine the following generated script before running."
        echo 
        echo "# <===== BEGIN ====>"
        cat ${CMD_SCRIPT}
        echo "# <====== END =====>"
        echo
    fi
    
    read -p "Run the generated script (y/n)? " run_generated_script
    if [ $run_generated_script = "y" ] || [ $run_generated_script = "yes" ] 
    then
        echo
        . ${CMD_SCRIPT}
        echo
    else
        echo
        echo "Script not run."
        echo
    fi
        
    rm ${CMD_SCRIPT}

    exit $1
}

# Script execution begins here.

PROJECT_NAME="$2"
[ ${GENERATE_COMMANDS_ONLY} == "true" ] && CMD_SCRIPT=$(mktemp)

# Process the actual command
case "$1" in
    ""|help|-h|--help)
        cmd_help
        ;;
    create)
        [ -z ${PROJECT_NAME} ] && cmd_quit "no project specified"
        cmd_create ${PROJECT_NAME}
        ;;
    archive)
        [ -z ${PROJECT_NAME} ] && cmd_quit "no project specified"
        cmd_archive ${PROJECT_NAME}
        ;;
    delete)
        [ -z ${PROJECT_NAME} ] && cmd_quit "no project specified"
        cmd_delete ${PROJECT_NAME}
        ;;
    *)
        cmd_quit "Sorry, I didn't understand the command \"$1\". Exiting." 127
        ;;
esac

