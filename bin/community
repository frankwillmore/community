#!/usr/bin/env bash 

# (C) 2021 Argonne Leadership Computing Facility, with primary concept by Frank Willmore
# This is free software with no implied warranty.

# Source .communityrc to pick up local values
[ -e ${COMMUNITY_ROOT}/etc/.communityrc ] && . ${COMMUNITY_ROOT}/etc/.communityrc

# set defaults if not found in .communityrc
: ${COMMUNITY_ROOT:=/tmp/community}
: ${GENERATE_COMMANDS_ONLY:=true}
: ${COMMUNITY_SCRIPT_DEBUG:="n"}
: ${COMMUNITY_ROOT:="/tmp/community"}
: ${EXISTING_PROJECT_PATH:="/projects"}
: ${COMMUNITY_PROJECT_DIR=${COMMUNITY_ROOT}/projects}
: ${COMMUNITY_PROJECT_MODULE_DIR=${COMMUNITY_ROOT}/modulefiles}

#COMMUNITY_PROJECT_DIR=${COMMUNITY_ROOT}/projects
#COMMUNITY_PROJECT_MODULE_DIR=${COMMUNITY_ROOT}/modulefiles

debug()
{
    [ ${COMMUNITY_SCRIPT_DEBUG} = "y" ] && echo "DEBUG: $@"
}

cmd_help() 
{
    printf "\n"
    printf "usage: community [ command ] [ community_name ]\n"
    printf "\n"
    printf "Where command is one of { create, delete, archive }\n" 
    printf "and community_name is the name of the community.\n"
    printf "\n" 
    printf "To specify a different community location, set COMMUNITY_ROOT\n"
    printf "(Default value is COMMUNITY_ROOT=/tmp/community)\n"
    printf "\n"
    printf "For deubgging info, set COMMUNITY_SCRIPT_DEBUG=y.\n"
    printf "\n"
    printf "By default, this program runs in 'safe mode', i.e."
    printf "commands will be generated and printed stdout but not executed.\n"
    printf "To automatically execute generated commands,\n"
    printf "set GENERATE_COMMANDS_ONLY to any value besides \"true\".\n"
    printf "\n"
    printf "\n"
}

cmd_create() 
{
    # PROJECT_DESCRIPTION, PROJECT_NAME, PROJECT_CONTACT, and PROJECT_ROOT are all 
    # tokens in the module template to be replaced. PROJECT_NAME is the 1st arg. 

    PROJECT_NAME=$1
    PROJECT_ROOT="${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}"
    MODULE_ROOT="${COMMUNITY_PROJECT_MODULE_DIR}/${PROJECT_NAME}"

    # check project eligibility
    eligible="false"
    for path in $(echo ${EXISTING_PROJECT_PATH} | sed -e "s/:/ /g")
    do
        debug "searching ${path}..."
        echo ${path}/${PROJECT_NAME} 
        if [ -e ${path}/${PROJECT_NAME} ] 
        then 
            eligible="true" 
            echo "found elgible path: ${path}/${PROJECT_NAME}"
        fi
    done
    [ ${eligible} = "true" ] || cmd_quit "Project ${PROJECT_NAME} not found." 126
    
    echo "creating community in ${PROJECT_ROOT} for project ${PROJECT_NAME}:"
    echo

    echo "Checking community doesn't already exist...."
    echo
    [ -e ${PROJECT_ROOT} ] && cmd_quit "Project ${PROJECT_NAME} already exists" 126

    # All is well, fill out module template fields.

    read -p "Please enter brief project_description: " PROJECT_DESCRIPTION
    debug "got PROJECT_DESCRIPTON=${PROJECT_DESCRIPTION}"
    echo

    read -p "Please enter project contact: " PROJECT_CONTACT
    debug "got PROJECT_DESCRIPTON=${PROJECT_DESCRIPTION}"
    echo

    read -p "Please enter project user owner: " PROJECT_USER_OWNER
    debug "got PROJECT_USER_OWNER=${PROJECT_USER_OWNER}"
    echo

    read -p "Please enter project group owner: " PROJECT_GROUP_OWNER
    debug "got PROJECT_GROUP_OWNER=${PROJECT_GROUP_OWNER}"
    echo

    # Done gathering info, now go do it.

    printf "creating software directory ${PROJECT_ROOT}..."
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo mkdir -p ${PROJECT_ROOT}" | tee -a ${CMD_SCRIPT} 
    else 
        mkdir -p ${PROJECT_ROOT}
    fi
    printf "done.\n"

    printf "creating module directory ${MODULE_ROOT}..."
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo mkdir -p ${MODULE_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        mkdir -p ${MODULE_ROOT}
    fi
    printf "done.\n"

    TEMPLATED_MODULE=${MODULE_ROOT}/${PROJECT_NAME}
    printf "adding template module file ${TEMPLATED_MODULE}..."
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo cp ${COMMUNITY_ROOT}/module_templates/module_template.tcl ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
    else 
        cp ${COMMUNITY_ROOT}/module_templates/module_template.tcl ${TEMPLATED_MODULE}
    fi
    printf "done.\n"

    printf "Replacing module template tokens with project info..."
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo sed -i -e \"s/\[\[PROJECT_NAME\]\]/${PROJECT_NAME}/g\" ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
        echo "sudo sed -i -e \"s#\[\[PROJECT_ROOT\]\]#${PROJECT_ROOT}#g\" ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
        echo "sudo sed -i -e \"s/\[\[PROJECT_CONTACT\]\]/${PROJECT_CONTACT}/g\" ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
        echo "sudo sed -i -e \"s/\[\[PROJECT_DESCRIPTION\]\]/${PROJECT_DESCRIPTION}/g\" ${TEMPLATED_MODULE}" | tee -a ${CMD_SCRIPT} 
    else
        sed -i -e "s/\[\[PROJECT_NAME\]\]/${PROJECT_NAME}/g" ${TEMPLATED_MODULE}
        sed -i -e "s#\[\[PROJECT_ROOT\]\]#${PROJECT_ROOT}#g" ${TEMPLATED_MODULE}
        sed -i -e "s/\[\[PROJECT_CONTACT\]\]/${PROJECT_CONTACT}/g" ${TEMPLATED_MODULE}
        sed -i -e "s/\[\[PROJECT_DESCRIPTION\]\]/${PROJECT_DESCRIPTION}/g" ${TEMPLATED_MODULE}
    fi
    printf "done.\n"

    echo "making project dirs:"
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo mkdir -p ${PROJECT_ROOT}/bin" | tee -a ${CMD_SCRIPT} 
        echo "sudo mkdir -p ${PROJECT_ROOT}/share/man" | tee -a ${CMD_SCRIPT} 
        echo "sudo mkdir -p ${PROJECT_ROOT}/lib64" | tee -a ${CMD_SCRIPT} 
        echo "sudo mkdir -p ${PROJECT_ROOT}/lib64/pkgconfig" | tee -a ${CMD_SCRIPT} 
    else
        mkdir -p ${PROJECT_ROOT}/bin
        mkdir -p ${PROJECT_ROOT}/share/man
        mkdir -p ${PROJECT_ROOT}/lib64
        mkdir -p ${PROJECT_ROOT}/lib64/pkgconfig
    fi

    echo "setting ownership..."
    
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo chown -R ${PROJECT_USER_OWNER}:${PROJECT_GROUP_OWNER} ${PROJECT_ROOT}" | tee -a ${CMD_SCRIPT} 
        echo "sudo chown -R ${PROJECT_USER_OWNER}:${PROJECT_GROUP_OWNER} ${MODULE_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        sudo chown -R ${PROJECT_USER_OWNER}:${PROJECT_GROUP_OWNER} ${PROJECT_ROOT}
        sudo chown -R ${PROJECT_USER_OWNER}:${PROJECT_GROUP_OWNER} ${MODULE_ROOT}
    fi

    printf "done.\n"

    cmd_exit 0
}

cmd_delete() 
{
    debug "deleting $1"

    PROJECT_NAME=$1
    PROJECT_ROOT="${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}"
    MODULE_ROOT="${COMMUNITY_PROJECT_MODULE_DIR}/${PROJECT_NAME}"
    
    echo "preparing to delete installs in ${PROJECT_ROOT}"
    echo "and modules in ${MODULE_ROOT} for project ${PROJECT_NAME}:"
    echo
    printf "Checking if community exists...."
    sleep 1
    if [ -e ${PROJECT_ROOT} ] 
    then 
        printf "yes.\n\n"
    else 
        printf "no.\n\n"
        cmd_quit "Project ${PROJECT_NAME} does not exist." 126
    fi

    read -p "Confirm delete (enter 'y' to confirm)? " confirm
    [ ${confirm} == "y" ] || cmd_quit "Change not confirmed. Exiting." 0

    echo "removing software directory ${PROJECT_ROOT}"
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo rm -rfv ${PROJECT_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        rm -rfv ${PROJECT_ROOT}
    fi
    echo

    echo "removing software directory ${PROJECT_ROOT}"
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ] 
    then
        echo "sudo rm -rfv ${PROJECT_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        rm -rfv ${PROJECT_ROOT}
    fi
    echo

    echo "deleting module directory ${MODULE_ROOT}"
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
    then
        echo "sudo rm -rfv ${MODULE_ROOT}" | tee -a ${CMD_SCRIPT} 
    else
        rm -rfv ${MODULE_ROOT}
    fi
    echo

    echo "Done!"
    echo

    cmd_exit 0
}

cmd_archive() 
{
    echo "archiving $PROJECT_NAME"
    printf "Change user ownership of ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME} to community?\n"
    read -p "(enter y to confirm) " confirm
    if [ $confirm = "y" ] || [ $confirm = "yes" ] 
    then
        if [ ${GENERATE_COMMANDS_ONLY} == "true" ]
        then
            echo "sudo chown -R ${ARCHIVE_USER_OWNER}:${ARCHIVE_GROUP_OWNER} ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}" | tee -a ${CMD_SCRIPT} 
            echo "sudo chmod -w -R ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}" | tee -a ${CMD_SCRIPT} 
        else
            sudo chown -R ${ARCHIVE_USER_OWNER}:${ARCHIVE_GROUP_OWNER} ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}
            sudo chmod -w -R ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}
        fi
    else
        echo "declining to update."
    fi

    cmd_exit 0
}

cmd_exit()
{ 
    if [ ${GENERATE_COMMANDS_ONLY} == "true" ]  
    then 
        echo 
        echo
        echo "Commands generated."
        echo
        echo "Examine the following script and, if satisfied, run as sudo."
        echo 
        echo "# <===== BEGIN ====>"
        cat ${CMD_SCRIPT}
        echo "# <====== END =====>"
        echo
        
        rm ${CMD_SCRIPT}
    fi
    exit $1
}

# Print the message $1 and exit with the provided return code $2
cmd_quit()
{
    echo "FAIL: $1"
    echo "FAIL: exiting with code $2"
    exit $2
}

# Script execution begins here.

PROJECT_NAME="$2"
[ ${GENERATE_COMMANDS_ONLY} == "true" ] && CMD_SCRIPT=$(mktemp)

# Process the actual command
case "$1" in
    ""|help|-h|--help)
        cmd_help
        ;;
    create)
        [ -z ${PROJECT_NAME} ] && cmd_quit "no project specified"
        cmd_create ${PROJECT_NAME}
        ;;
    archive)
        [ -z ${PROJECT_NAME} ] && cmd_quit "no project specified"
        cmd_archive ${PROJECT_NAME}
        ;;
    delete)
        [ -z ${PROJECT_NAME} ] && cmd_quit "no project specified"
        cmd_delete ${PROJECT_NAME}
        ;;
    *)
        cmd_quit "Sorry, I didn't understand the command \"$1\". Exiting." 127
        ;;
esac

