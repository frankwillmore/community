#!/usr/bin/env bash 

: ${COMMUNITY_ROOT:=/tmp/community}

# Source .communityrc to pick up local values
[ -e ${COMMUNITY_ROOT}/etc/.communityrc ] && . ${COMMUNITY_ROOT}/etc/.communityrc

# set defaults if not found in .communityrc
: ${COMMUNITY_SCRIPT_DEBUG:="y"}
: ${COMMUNITY_ROOT:="/tmp/community"}
: ${EXISTING_PROJECT_PATH:="/projects"}

COMMUNITY_PROJECT_DIR=${COMMUNITY_ROOT}/projects
COMMUNITY_PROJECT_MODULE_DIR=${COMMUNITY_ROOT}/modulefiles

debug()
{
    [ ${COMMUNITY_SCRIPT_DEBUG} = "y" ] && echo "DEBUG: $@"
}

cmd_help() 
{
    printf "\n"
    printf "usage: community [ command ] [ community_name ]\n\n"
    printf "Where command is one of { create, delete, archive }\n" 
    printf "and community_name is the name of the community.\n\n" 
    printf "To specify a different community location, set COMMUNITY_ROOT\n"
    printf "(Default value is COMMUNITY_ROOT=/tmp/community)\n\n"
    printf "For deubgging info, set COMMUNITY_SCRIPT_DEBUG=y."
    printf "\n"
    printf "\n"
}

cmd_create() 
{
    # PROJECT_DESCRIPTION, PROJECT_NAME, PROJECT_CONTACT, and PROJECT_ROOT are all 
    # tokens in the module template to be replaced. PROJECT_NAME is the 1st arg. 

    PROJECT_NAME=$1
    PROJECT_ROOT="${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}"
    MODULE_ROOT="${COMMUNITY_PROJECT_MODULE_DIR}/${PROJECT_NAME}"

    # check project eligibility
    eligible="false"
    for path in $(echo ${EXISTING_PROJECT_PATH} | sed -e "s/:/ /g")
    do
        debug "searching ${path}..."
        echo ${path}/${PROJECT_NAME} 
        if [ -e ${path}/${PROJECT_NAME} ] 
        then 
            eligible="true" 
            echo "found elgible path: ${path}/${PROJECT_NAME}"
        fi
    done
    [ ${eligible} = "true" ] || cmd_quit "Project ${PROJECT_NAME} not found." 126
    
    echo "creating community in ${PROJECT_ROOT} for project ${PROJECT_NAME}:"
    echo

    echo "Checking community doesn't already exist...."
    echo
    [ -e ${PROJECT_ROOT} ] && cmd_quit "Project ${PROJECT_NAME} already exists" 126

    # All is well, fill out module template fields.

    read -p "Please enter brief project_description: " PROJECT_DESCRIPTION
    debug "got PROJECT_DESCRIPTON=${PROJECT_DESCRIPTION}"
    echo

    read -p "Please enter project contact: " PROJECT_CONTACT
    debug "got PROJECT_DESCRIPTON=${PROJECT_DESCRIPTION}"
    echo

    printf "creating software directory ${PROJECT_ROOT}..."
    mkdir -p ${PROJECT_ROOT}
    printf "done.\n"

    printf "creating module directory ${MODULE_ROOT}..."
    mkdir -p ${MODULE_ROOT}
    printf "done.\n"

    TEMPLATED_MODULE=${MODULE_ROOT}/${PROJECT_NAME}
    printf "adding template module file ${TEMPLATED_MODULE}..."
    cp ${COMMUNITY_ROOT}/module_templates/module_template.tcl ${TEMPLATED_MODULE}
    printf "done.\n"

    printf "Replacing module template tokens with project info..."
    sed -i -e "s/\[\[PROJECT_NAME\]\]/${PROJECT_NAME}/g" ${TEMPLATED_MODULE}
    sed -i -e "s#\[\[PROJECT_ROOT\]\]#${PROJECT_ROOT}#g" ${TEMPLATED_MODULE}
    sed -i -e "s/\[\[PROJECT_CONTACT\]\]/${PROJECT_CONTACT}/g" ${TEMPLATED_MODULE}
    sed -i -e "s/\[\[PROJECT_DESCRIPTION\]\]/${PROJECT_DESCRIPTION}/g" ${TEMPLATED_MODULE}
    printf "done.\n"

    echo "making project dirs:"
    mkdir -p ${PROJECT_ROOT}/bin
    mkdir -p ${PROJECT_ROOT}/share/man
    mkdir -p ${PROJECT_ROOT}/lib64
    mkdir -p ${PROJECT_ROOT}/lib64/pkgconfig

    printf "done.\n"
}

cmd_delete() 
{
    debug "deleting $1"

    PROJECT_NAME=$1
    PROJECT_ROOT="${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}"
    MODULE_ROOT="${COMMUNITY_PROJECT_MODULE_DIR}/${PROJECT_NAME}"
    
    echo "preparing to delete installs in ${PROJECT_ROOT}"
    echo "and modules in ${MODULE_ROOT} for project ${PROJECT_NAME}:"
    echo
    printf "Checking if community exists...."
    sleep 1
    if [ -e ${PROJECT_ROOT} ] 
    then 
        printf "yes.\n\n"
    else 
        printf "no.\n\n"
        cmd_quit "Project ${PROJECT_NAME} does not exist." 126
    fi

    read -p "Confirm delete (enter 'y' to confirm)? " confirm
    [ ${confirm} = "y" ] || cmd_quit "Change not confirmed. Exiting." 0

    echo "removing software directory ${PROJECT_ROOT}"
    rm -rfv ${PROJECT_ROOT}
    echo

    echo "deleting module directory ${MODULE_ROOT}"
    rm -rfv ${MODULE_ROOT}
    echo

    echo "Done!"
    echo
}

cmd_archive() 
{
    echo "archiving $1"
#    read -p "change user ownership of ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME} to community? (enter y to confirm)" confirm
#    if [ $confirm = "y" ] || [ $confirm = "yes" ] 
#    then
#        # chown -R community ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME} 
#        echo "chown -R community ${COMMUNITY_PROJECT_DIR}/${PROJECT_NAME}"
#    else
#        echo "declining to update."
#    fi
}

# Print the message $1 and exit with the provided return code $2
cmd_quit()
{
    echo "FAIL: $1"
    echo "FAIL: exiting with code $2"
    exit $2
}

# Where script execution begins
PROJECT_NAME="$2"
#if [ -z ${PROJECT_NAME} ] 
#then
#    cmd_help
#    cmd_quit "no project name specified."
#else
#    debug "got PROJECT_NAME=$PROJECT_NAME" "and some other info"
#fi

# Process the actual command
case "$1" in
    ""|help|-h|--help)
        cmd_help
        ;;
    create)
        cmd_create ${PROJECT_NAME}
        ;;
    archive)
        cmd_archive ${PROJECT_NAME}
        ;;
    delete)
        cmd_delete ${PROJECT_NAME}
        ;;
    *)
        cmd_quit "Sorry, I didn't understand the command \"$1\". Exiting." 127
        ;;
esac

